name: SonarQube Analysis

on:
  push:
    branches:
      - main
      - staging/*
      - next_stable
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  sonarqube:
    name: SonarQube Analysis
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Shallow clones should be disabled for better relevancy of analysis

    - name: Setup Java
      uses: actions/setup-java@v3
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Setup Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: '3.0'
        bundler-cache: false

    - name: Install build dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential gcc-arm-none-eabi cppcheck gcovr jq
        gem install ceedling

    - name: Cache SonarQube packages
      uses: actions/cache@v3
      with:
        path: ~/.sonar/cache
        key: ${{ runner.os }}-sonar
        restore-keys: ${{ runner.os }}-sonar

    - name: Run cppcheck for SonarQube
      run: |
        mkdir -p sonar-reports
        # Run cppcheck with XML output for SonarQube
        cppcheck --enable=all --xml --xml-version=2 \
          --output-file=sonar-reports/cppcheck-report.xml \
          --project=drivers/ drivers/ 2>/dev/null || true

    - name: Run tests with coverage
      run: |
        # Generate coverage reports for SonarQube
        mkdir -p sonar-reports/coverage

        # Find and run all tests
        test_dirs=$(find tests -name "project.yml" -type f -exec dirname {} \;)
        for test_dir in $test_dirs; do
          echo "Running tests in: $test_dir"
          cd "$test_dir"
          ceedling gcov:all || true

          # Convert coverage to SonarQube format
          if [ -d "build/artifacts/gcov" ]; then
            gcovr --xml --xml-pretty \
              --output ../../sonar-reports/coverage/coverage-${test_dir##*/}.xml \
              build/artifacts/gcov/ || true
          fi
          cd - > /dev/null
        done

    - name: Create sonar-project.properties
      run: |
        cat > sonar-project.properties << EOF
        # Project identification
        sonar.projectKey=${{ github.repository_owner }}_no-OS
        sonar.organization=${{ github.repository_owner }}
        sonar.projectName=no-OS
        sonar.projectVersion=1.0

        # Source code
        sonar.sources=drivers/,iio/,jesd204/,libraries/,network/,include/
        sonar.tests=tests/

        # Language configuration
        sonar.c.file.suffixes=.c,.h
        sonar.cpp.file.suffixes=.cpp,.hpp,.cxx,.hxx

        # Coverage and test reports
        sonar.coverageReportPaths=sonar-reports/coverage/*.xml
        sonar.cxx.cppcheck.reportPaths=sonar-reports/cppcheck-report.xml

        # Exclusions
        sonar.exclusions=**/build/**,**/libraries/**,**/tests/**/build/**
        sonar.test.exclusions=**/build/**

        # Additional settings
        sonar.sourceEncoding=UTF-8
        sonar.analysis.mode=publish
        EOF

    - name: Run SonarQube Scan
      uses: sonarqube/sonarqube-scanner-action@v2.3.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

    - name: Wait for Quality Gate
      id: wait-for-quality-gate
      uses: sonarqube/sonarqube-quality-gate-action@master
      timeout-minutes: 5
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
      with:
        scanMetadataReportFile: .scannerwork/report-task.txt

    - name: Get SonarQube Analysis Results
      id: sonar-analysis
      if: always()
      run: |
        # Project key for API calls
        PROJECT_KEY="${{ github.repository_owner }}_no-OS"

        # Get quality gate status from the previous step's output or API fallback
        QUALITY_GATE="UNKNOWN"
        if [ "${{ steps.wait-for-quality-gate.outcome }}" = "success" ]; then
          QUALITY_GATE="OK"
        elif [ "${{ steps.wait-for-quality-gate.outcome }}" = "failure" ]; then
          QUALITY_GATE="ERROR"
        else
          # Try API call as fallback
          QUALITY_GATE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
            "${{ secrets.SONAR_HOST_URL }}/api/qualitygates/project_status?projectKey=${PROJECT_KEY}" \
            2>/dev/null | jq -r '.projectStatus.status // "UNKNOWN"' 2>/dev/null || echo "UNKNOWN")
        fi

        # Initialize default values
        BUGS="0"
        VULNERABILITIES="0"
        CODE_SMELLS="0"
        COVERAGE="0"
        DUPLICATED_LINES="0"
        LINES_OF_CODE="0"
        MAINTAINABILITY_RATING="1"

        # Try to get metrics with error handling
        if command -v jq >/dev/null 2>&1 && [ -n "${{ secrets.SONAR_TOKEN }}" ]; then
          METRICS=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
            "${{ secrets.SONAR_HOST_URL }}/api/measures/component?component=${PROJECT_KEY}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,ncloc,sqale_rating" \
            2>/dev/null | jq -r '.component.measures // []' 2>/dev/null || echo "[]")

          if [ "$METRICS" != "[]" ] && [ "$METRICS" != "null" ]; then
            # Parse metrics safely
            BUGS=$(echo "$METRICS" | jq -r '.[] | select(.metric=="bugs") | .value // "0"' 2>/dev/null || echo "0")
            VULNERABILITIES=$(echo "$METRICS" | jq -r '.[] | select(.metric=="vulnerabilities") | .value // "0"' 2>/dev/null || echo "0")
            CODE_SMELLS=$(echo "$METRICS" | jq -r '.[] | select(.metric=="code_smells") | .value // "0"' 2>/dev/null || echo "0")
            COVERAGE=$(echo "$METRICS" | jq -r '.[] | select(.metric=="coverage") | .value // "0"' 2>/dev/null || echo "0")
            DUPLICATED_LINES=$(echo "$METRICS" | jq -r '.[] | select(.metric=="duplicated_lines_density") | .value // "0"' 2>/dev/null || echo "0")
            LINES_OF_CODE=$(echo "$METRICS" | jq -r '.[] | select(.metric=="ncloc") | .value // "0"' 2>/dev/null || echo "0")
            MAINTAINABILITY_RATING=$(echo "$METRICS" | jq -r '.[] | select(.metric=="sqale_rating") | .value // "1"' 2>/dev/null || echo "1")
          fi
        fi

        # Parse metrics
        BUGS=$(echo "$METRICS" | jq -r '.[] | select(.metric=="bugs") | .value // "0"')
        VULNERABILITIES=$(echo "$METRICS" | jq -r '.[] | select(.metric=="vulnerabilities") | .value // "0"')
        CODE_SMELLS=$(echo "$METRICS" | jq -r '.[] | select(.metric=="code_smells") | .value // "0"')
        COVERAGE=$(echo "$METRICS" | jq -r '.[] | select(.metric=="coverage") | .value // "0"')
        DUPLICATED_LINES=$(echo "$METRICS" | jq -r '.[] | select(.metric=="duplicated_lines_density") | .value // "0"')
        LINES_OF_CODE=$(echo "$METRICS" | jq -r '.[] | select(.metric=="ncloc") | .value // "0"')
        MAINTAINABILITY_RATING=$(echo "$METRICS" | jq -r '.[] | select(.metric=="sqale_rating") | .value // "1"')

        echo "QUALITY_GATE=$QUALITY_GATE" >> $GITHUB_ENV
        echo "BUGS=$BUGS" >> $GITHUB_ENV
        echo "VULNERABILITIES=$VULNERABILITIES" >> $GITHUB_ENV
        echo "CODE_SMELLS=$CODE_SMELLS" >> $GITHUB_ENV
        echo "COVERAGE=$COVERAGE" >> $GITHUB_ENV
        echo "DUPLICATED_LINES=$DUPLICATED_LINES" >> $GITHUB_ENV
        echo "LINES_OF_CODE=$LINES_OF_CODE" >> $GITHUB_ENV
        echo "MAINTAINABILITY_RATING=$MAINTAINABILITY_RATING" >> $GITHUB_ENV

        # Generate SonarQube URL
        SONAR_URL="${{ secrets.SONAR_HOST_URL }}/dashboard?id=${PROJECT_KEY}"
        echo "SONAR_URL=$SONAR_URL" >> $GITHUB_ENV

    - name: Create SonarQube Dashboard Summary
      if: always()
      run: |
        # Convert maintainability rating to letter grade
        case "${{ env.MAINTAINABILITY_RATING }}" in
          "1") MAINTAINABILITY_GRADE="A" ;;
          "2") MAINTAINABILITY_GRADE="B" ;;
          "3") MAINTAINABILITY_GRADE="C" ;;
          "4") MAINTAINABILITY_GRADE="D" ;;
          "5") MAINTAINABILITY_GRADE="E" ;;
          *) MAINTAINABILITY_GRADE="Unknown" ;;
        esac

        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        ## ğŸ¯ SonarQube Quality Analysis

        ### ğŸš¦ Quality Gate: ${{ env.QUALITY_GATE == 'OK' && 'âœ… PASSED' || env.QUALITY_GATE == 'ERROR' && 'âŒ FAILED' || 'âš ï¸ UNKNOWN' }}

        ### ğŸ“Š Code Quality Metrics

        | Metric | Value | Status |
        |--------|-------|--------|
        | ğŸ› Bugs | ${{ env.BUGS }} | ${{ env.BUGS == '0' && 'âœ…' || 'âŒ' }} |
        | ğŸ” Vulnerabilities | ${{ env.VULNERABILITIES }} | ${{ env.VULNERABILITIES == '0' && 'âœ…' || 'ğŸš¨' }} |
        | ğŸ‘ƒ Code Smells | ${{ env.CODE_SMELLS }} | ${{ env.CODE_SMELLS < 10 && 'âœ…' || env.CODE_SMELLS < 50 && 'âš ï¸' || 'âŒ' }} |
        | ğŸ“ˆ Coverage | ${{ env.COVERAGE }}% | ${{ env.COVERAGE >= 80 && 'âœ…' || env.COVERAGE >= 60 && 'âš ï¸' || 'âŒ' }} |
        | ğŸ“‹ Duplicated Lines | ${{ env.DUPLICATED_LINES }}% | ${{ env.DUPLICATED_LINES < 3 && 'âœ…' || env.DUPLICATED_LINES < 5 && 'âš ï¸' || 'âŒ' }} |
        | ğŸ“ Lines of Code | ${{ env.LINES_OF_CODE }} | â„¹ï¸ |
        | ğŸ”§ Maintainability | $MAINTAINABILITY_GRADE | ${{ env.MAINTAINABILITY_RATING <= 2 && 'âœ…' || env.MAINTAINABILITY_RATING <= 3 && 'âš ï¸' || 'âŒ' }} |

        ### ğŸ”— Links
        - [ğŸ“Š View Full SonarQube Dashboard](${{ env.SONAR_URL }})
        - [ğŸ“ˆ View Metrics History](${{ env.SONAR_URL }}&tab=measures)
        - [ğŸ› View Issues](${{ env.SONAR_URL }}&tab=issues)

        ### ğŸ“‹ Recommendations
        ${{ env.BUGS > 0 && 'ğŸ› **Fix bugs** - Zero bugs policy recommended for production code\n' || '' }}${{ env.VULNERABILITIES > 0 && 'ğŸ” **Address security vulnerabilities** - Critical for application security\n' || '' }}${{ env.COVERAGE < 80 && 'ğŸ“ˆ **Improve test coverage** - Target: 80%+ coverage\n' || '' }}${{ env.DUPLICATED_LINES > 3 && 'ğŸ“‹ **Reduce code duplication** - Extract common functionality\n' || '' }}${{ env.CODE_SMELLS > 50 && 'ğŸ‘ƒ **Address code smells** - Improve code maintainability\n' || '' }}
        EOF

    - name: Comment PR with SonarQube Results
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const qualityGateStatus = process.env.QUALITY_GATE === 'OK' ? 'âœ… PASSED' :
                                   process.env.QUALITY_GATE === 'ERROR' ? 'âŒ FAILED' : 'âš ï¸ UNKNOWN';

          const comment = `## ğŸ¯ SonarQube Analysis Results

          **Quality Gate: ${qualityGateStatus}**

          | Metric | Value |
          |--------|-------|
          | ğŸ› Bugs | ${process.env.BUGS} |
          | ğŸ” Vulnerabilities | ${process.env.VULNERABILITIES} |
          | ğŸ‘ƒ Code Smells | ${process.env.CODE_SMELLS} |
          | ğŸ“ˆ Coverage | ${process.env.COVERAGE}% |
          | ğŸ“‹ Duplicated Lines | ${process.env.DUPLICATED_LINES}% |

          [ğŸ“Š View Full Report](${process.env.SONAR_URL})
          `;

          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

    - name: Fail if Quality Gate Failed
      if: env.QUALITY_GATE == 'ERROR'
      run: |
        echo "âŒ SonarQube Quality Gate failed!"
        exit 1
